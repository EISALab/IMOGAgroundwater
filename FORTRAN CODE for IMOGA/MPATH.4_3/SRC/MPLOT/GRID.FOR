C MODPATH-PLOT Version 3.00 (V3, Release 2, 5-99)
C Changes:
C   No change since previous release: (V3, Release 1, 9-94)
C***** SUBROUTINES *****
C     DXGRID
C     DMGRID
C     COMBIN
C     GETPTS
C     XDCB
C     XDVLIN
C     XIGLIN
C     XOGZ
C     XOZONE
C     XSGZ
C     XSZONE
C     XSIAC
C     EXTENT
C     MATCH
C     PINCH
C     TRMPTS
C     TOPWT
C     NOTATE
C     GETCPT
C     DLEGND
C     WTDRAW
C***********************
 
C***** SUBROUTINE *****
      SUBROUTINE DXGRID(IXGZ,IXMASK,IB,ZXT,ZXB,X,XMIN,XMAX,NZ,NX,
     2 XPTS,ZPTS,XPTS1,ZPTS1,XPTS2,ZPTS2,ICB,IGEOL,NGEOL,IACPAT,NXF,
     3 NXL,NZF,NZL,ISGZ,ICBPAT,IGRLIN,IOPT,ICIGL,ICAGB,ICCBL,ICCBF,
     4 ICIAC,ICSGZ,MAXPTS)
C
      DIMENSION IXGZ(NX,NZ),IB(NX,NZ),ZXT(NX,NZ),ZXB(NX,NZ),
     1 X(NX),XMIN(NX),XMAX(NX),XPTS(2*MAXPTS+1),ZPTS(2*MAXPTS+1),
     2 XPTS1(MAXPTS),ZPTS1(MAXPTS),XPTS2(MAXPTS),ZPTS2(MAXPTS),ICB(NX),
     3 IGEOL(2*NGEOL),IXMASK(NX,NZ)
 
      IOP=IOPT
      IF(IOP.EQ.2) THEN
        IOP=1
        DO 2 IZ=1,NZ
        DO 2 IX=1,NX
2       IF(IB(IX,IZ).EQ.0) IB(IX,IZ)=9999
      END IF
 
C   GET THE VALUE OF THE CURRENT LINE COLOR SO THAT IT CAN BE RESTORED LATER.
      CALL GQPLCI(IERR,ICOLD)
      CALL GQFACI(IERR,IFOLD)
      CALL QFAST(IFSOLD)
 
C   OUTLINE GRID RECTANGLE
      IF(IOP.EQ.3) THEN
        CALL GSPLCI(ICIGL)
 
        IF(IACPAT.GT.0) THEN
          CALL SFAST(IACPAT)
          CALL GSFACI(ICIAC)
          DO 5 K=1,NZ
          DO 5 J=1,NX
          IF(IB(J,K).EQ.0) THEN
            IXMASK(J,K)=1
          ELSE
            IXMASK(J,K)=0
          END IF
5         CONTINUE
          CALL XSIAC(ZXT,ZXB,IXMASK,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1      X,XMIN,XMAX,XPTS1,ZPTS1,XPTS2,ZPTS2,MAXPTS)
        END IF
 
      END IF
 
C   FIND OUT IF THE GEOLOGIC ZONE ARRAY HAS ANY NON-ZERO ZONES AND IF THERE
C   ARE ANY QUASI-3D CONFINING LAYERS WITH NON-ZERO THICKNESS
      NCB=1
      I=0
      II=0
      DO 1 K=NZF,NZL
      DO 1 J=NXF,NXL
      IF(K.LT.NZL) THEN
        IF( (ZXB(J,K)-ZXT(J,K+1)).GT.0.0 ) II=1
      END IF
1     IF(IXGZ(J,K).NE.0) I=1
      IF(I.EQ.0) ISGZ=0
      IF(II.EQ.0) NCB=0
 
C   SHADE GEOLOGIC ZONES
      IF(ISGZ.GE.2) THEN
        CALL XSGZ(ZXT,ZXB,IXGZ,XPTS,ZPTS,NX,NZ,NXF,
     1  NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,XPTS1,ZPTS1,XPTS2,
     2  ZPTS2,MAXPTS,ISGZ)
      END IF
 
C   DRAW INTERIOR GRID LINES
      IF(IGRLIN.EQ.1) THEN
        CALL GSPLCI(ICIGL)
        CALL XIGLIN(ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1  X,XMIN,XMAX,MAXPTS)
      END IF
 
C   OUTLINE GEOLOGIC ZONES
      IF(ISGZ.EQ.1 .OR. ISGZ.EQ.3) THEN
        IF(IGRLIN.EQ.0) THEN
          CALL GSPLCI(ICIGL)
          CALL XOGZ(ZXT,ZXB,IXGZ,IXMASK,XPTS,ZPTS,NX,NZ,NXF,
     1       NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,MAXPTS,ISGZ,ICSGZ)
        END IF
      ELSE IF(ISGZ.EQ.2 .AND. ICSGZ.GT.0) THEN
        CALL GSPLCI(ICSGZ)
        CALL XOGZ(ZXT,ZXB,IXGZ,IXMASK,XPTS,ZPTS,NX,NZ,NXF,
     1     NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,MAXPTS,ISGZ,ICSGZ)
      END IF
 
C   OUTLINE INACTIVE CELLS
      IF(IOP.EQ.3) THEN
        CALL GSPLCI(ICIGL)
        DO 10 K=1,NZ
        DO 10 J=1,NX
10      IXMASK(J,K)=1
        CALL XOZONE(ZXT,ZXB,IXMASK,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,X,
     1    XMIN,XMAX,MAXPTS)
      END IF
 
 
C   OUTLINE ACTIVE GRID
      CALL GSPLCI(ICAGB)
      CALL XOZONE(ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,X,XMIN,
     1  XMAX,MAXPTS)
 
C   SHADE AND OUTLINE QUASI-3D CONFINING LAYERS
      CALL GSPLCI(ICCBL)
      CALL GSFACI(ICCBF)
      IF(NCB.GT.0) THEN
        ISHADE=0
        IF(ICBPAT.GT.0) THEN
          ISHADE=1
          CALL SFAST(ICBPAT)
        END IF
        CALL XDCB(ZXT,ZXB,ICB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,
     1   NZL,X,XMIN,XMAX,MAXPTS,XPTS1,ZPTS1,XPTS2,ZPTS2,ISHADE,IB)
      END IF
 
      DO 3 IZ=1,NZ
      DO 3 IX=1,NX
3     IF(IB(IX,IZ).EQ.9999) IB(IX,IZ)=0
 
      CALL GSPLCI(ICOLD)
      CALL GSFACI(IFOLD)
      CALL SFAST(IFSOLD)
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE DMGRID(IXGZ,IXMASK,IB,ZXT,ZXB,X,XMIN,XMAX,NZ,NX,
     2 XGMIN,XGMAX,ZGMIN,ZGMAX,XPTS,ZPTS,XPTS1,ZPTS1,XPTS2,ZPTS2,
     3 IGEOL,NGEOL,IACPAT,NXF,NXL,NZF,NZL,ISGZ,IGRLIN,IOPT,
     4 ICIGL,ICAGB,ICIAC,ICSGZ,MAXPTS)
C
      DIMENSION IXGZ(NX,NZ),IB(NX,NZ),ZXT(NX,NZ),ZXB(NX,NZ),
     1 X(NX),XMIN(NX),XMAX(NX),XPTS(2*MAXPTS+1),ZPTS(2*MAXPTS+1),
     2 XPTS1(MAXPTS),ZPTS1(MAXPTS),XPTS2(MAXPTS),ZPTS2(MAXPTS),
     3 IGEOL(2*NGEOL),IXMASK(NX,NZ)
      DIMENSION XB(5),ZB(5)
 
      IOP=IOPT
      IF(IOP.EQ.2) THEN
        IOP=1
        DO 2 IZ=1,NZ
        DO 2 IX=1,NX
2       IF(IB(IX,IZ).EQ.0) IB(IX,IZ)=9999
      END IF
 
C   GET THE VALUE OF THE CURRENT LINE COLOR SO THAT IT CAN BE RESTORED LATER.
      CALL GQPLCI(IERR,ICOLD)
      CALL GQFACI(IERR,IFOLD)
      CALL QFAST(IFSOLD)
 
C   OUTLINE GRID RECTANGLE
      IF(IOP.EQ.3) THEN
        CALL GSPLCI(ICIGL)
 
        IF(IACPAT.GT.0) THEN
          CALL SFAST(IACPAT)
          CALL GSFACI(ICIAC)
          DO 5 K=1,NZ
          DO 5 J=1,NX
          IF(IB(J,K).EQ.0) THEN
            IXMASK(J,K)=1
          ELSE
            IXMASK(J,K)=0
          END IF
5         CONTINUE
          CALL XSIAC(ZXT,ZXB,IXMASK,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1      X,XMIN,XMAX,XPTS1,ZPTS1,XPTS2,ZPTS2,MAXPTS)
        END IF
 
        XB(1)=XGMIN
        ZB(1)=ZGMIN
        XB(2)=XGMAX
        ZB(2)=ZB(1)
        XB(3)=XB(2)
        ZB(3)=ZGMAX
        XB(4)=XGMIN
        ZB(4)=ZB(3)
        XB(5)=XB(1)
        ZB(5)=ZB(1)
        CALL PLOTPL(5,XB,ZB)
      END IF
 
C   FIND OUT IF THE GEOLOGIC ZONE ARRAY HAS ANY NON-ZERO ZONES
      I=0
      DO 1 K=NZF,NZL
      DO 1 J=NXF,NXL
1     IF(IXGZ(J,K).NE.0) I=1
      IF(I.EQ.0) ISGZ=0
 
C   SHADE GEOLOGIC ZONES
      IF(ISGZ.GE.2) THEN
        CALL XSGZ(ZXT,ZXB,IXGZ,XPTS,ZPTS,NX,NZ,NXF,
     1  NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,XPTS1,ZPTS1,XPTS2,
     2  ZPTS2,MAXPTS,ISGZ)
      END IF
 
C   DRAW INTERIOR GRID LINES
      IF(IGRLIN.EQ.1) THEN
        CALL GSPLCI(ICIGL)
        CALL XIGLIN(ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1  X,XMIN,XMAX,MAXPTS)
      END IF
 
C   OUTLINE GEOLOGIC ZONES
      IF(ISGZ.EQ.1 .OR. ISGZ.EQ.3) THEN
        IF(IGRLIN.EQ.0) THEN
          CALL GSPLCI(ICIGL)
          CALL XOGZ(ZXT,ZXB,IXGZ,IXMASK,XPTS,ZPTS,NX,NZ,NXF,
     1       NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,MAXPTS,ISGZ,ICSGZ)
        END IF
      ELSE IF(ISGZ.EQ.2 .AND. ICSGZ.GT.0) THEN
        CALL GSPLCI(ICSGZ)
        CALL XOGZ(ZXT,ZXB,IXGZ,IXMASK,XPTS,ZPTS,NX,NZ,NXF,
     1     NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,MAXPTS,ISGZ,ICSGZ)
      END IF
 
C   OUTLINE ACTIVE GRID
      CALL GSPLCI(ICAGB)
      CALL XOZONE(ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,X,XMIN,
     1  XMAX,MAXPTS)
 
      DO 3 IZ=1,NZ
      DO 3 IX=1,NX
3     IF(IB(IX,IZ).EQ.9999) IB(IX,IZ)=0
 
      CALL GSPLCI(ICOLD)
      CALL GSFACI(IFOLD)
      CALL SFAST(IFSOLD)
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE COMBIN(X1,Z1,NP1,X2,Z2,NP2,XP,ZP,NP,MAXPTS,NBEGIN,
     1                  NCLOSE)
      DIMENSION X1(NP1),Z1(NP1),X2(NP2),Z2(NP2),XP(2*MAXPTS+1),
     1          ZP(2*MAXPTS+1)
C
C   IF FIRST POINT IS ON LEFT SIDE OF CURVE 1, SWAP THE ORDER OF POINTS
C   IN CURVE 2.
      IF(NBEGIN.EQ.0) THEN
        NHALF=NP2/2
        DO 10 N=1,NHALF
        NN=NP2+1-N
        XT=X2(N)
        ZT=Z2(N)
        Z2(N)=Z2(NN)
        X2(N)=X2(NN)
        Z2(NN)=ZT
        X2(NN)=XT
10      CONTINUE
C   IF FIRST POINT IS ON RIGHT SIDE OF CURVE 1, SWAP THE ORDER OF POINTS
C   IN CURVE 1
      ELSE
        NHALF=NP1/2
        DO 20 N=1,NHALF
        NN=NP1+1-N
        XT=X1(N)
        ZT=Z1(N)
        Z1(N)=Z1(NN)
        X1(N)=X1(NN)
        Z1(NN)=ZT
        X1(NN)=XT
20      CONTINUE
      END IF
 
      NP=0
      DO 30 N=1,NP1
      NP=NP+1
      XP(NP)=X1(N)
      ZP(NP)=Z1(N)
30    CONTINUE
 
      DO 40 N=1,NP2
      NP=NP+1
      XP(NP)=X2(N)
      ZP(NP)=Z2(N)
40    CONTINUE
 
C   ADD A POINT TO CLOSE THE CURVE, IF APPROPRIATE
      IF(NCLOSE.GT.0) THEN
      NP=NP+1
      XP(NP)=XP(1)
      ZP(NP)=ZP(1)
      END IF
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE GETPTS(JL,JR,K,Z,XMIN,XMAX,X,XP,ZP,NX,NZ,MAXPTS,
     1                  NLEFT,NRIGHT,NP)
C
      DIMENSION Z(NX,NZ),XMIN(NX),XMAX(NX),X(NX),XP(MAXPTS),ZP(MAXPTS)
C
      NP=0
C   CHECK FOR ERROR CONDITION AND RETURN "NP=0" IF THERE IS A PROBLEM
      IF(NLEFT.EQ.1 .AND. JL.EQ.1) RETURN
      IF(NRIGHT.EQ.1 .AND. JR.EQ.NX) RETURN
 
      DO 100 J=JL,JR
C   GENERATE INTERPOLATED POINT AT LEFT EDGE, IF APPROPRIATE
      IF(J.EQ.JL) THEN
        IF(NLEFT.EQ.1) THEN
          NP=NP+1
          XP(NP)=XMIN(JL)
          FAC=(XP(NP)-X(J-1))/(X(J)-X(J-1))
          ZP(NP)=(1.0-FAC)*Z(J-1,K) + FAC*Z(J,K)
        ELSE IF(NLEFT.EQ.2) THEN
          NP=NP+1
          XP(NP)=XMIN(J)
          ZP(NP)=Z(J,K)
        END IF
      END IF
 
C   ASSIGN POINT AT THE NODE
      NP=NP+1
      XP(NP)=X(J)
      ZP(NP)=Z(J,K)
 
C   GENERATE INTERPOLATED POINT AT RIGHT EDGE, IF APPROPRIATE
      IF(J.EQ.JR) THEN
        IF(NRIGHT.EQ.1) THEN
          NP=NP+1
          XP(NP)=XMAX(J)
          FAC= (XP(NP)-X(J))/(X(J+1)-X(J))
          ZP(NP)=(1.0-FAC)*Z(J,K) + FAC*Z(J+1,K)
        ELSE IF(NRIGHT.EQ.2) THEN
          NP=NP+1
          XP(NP)=XMAX(J)
          ZP(NP)=Z(J,K)
        END IF
      END IF
100   CONTINUE
      CALL TRMPTS(NP,XP,ZP,NPTRM)
      NP=NPTRM
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XDCB (ZXT,ZXB,ICB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1 X,XMIN,XMAX,MAXPTS,XPTS1,ZPTS1,XPTS2,ZPTS2,ISHADE,IB)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),ICB(NX),XPTS(2*MAXPTS+1),
     1   ZPTS(2*MAXPTS+1),X(NX),XMIN(NX),XMAX(NX),XPTS1(MAXPTS),
     2   ZPTS1(MAXPTS),XPTS2(MAXPTS),ZPTS2(MAXPTS),IB(NX,NZ)
C
 
C   FIND OUT IF NZL IS THE LAST LAYER IN THE GRID. IF IT IS, SKIP THE CHECK FOR THAT LAYER
      IF(NZL.EQ.NZ) THEN
      NL=NZL-1
      ELSE
      NL=NZL
      END IF
 
C   GO THROUGH EACH LAYER
      DO 10 K=NZF,NL
 
C   FILL THE ICB ARRAY FOR EACH LAYER: ICB=1 IF CB PRESENT; ICB=0 IF NO CB PRESENT.
      DO 15 J=1,NX
      IF( (ZXB(J,K)-ZXT(J,K+1)) .GT. 0.0 ) THEN
        IF(IB(J,K).EQ.0 .AND. IB(J,K+1).EQ.0) THEN
          ICB(J)=0
        ELSE
          ICB(J)=1
        END IF
      ELSE
        ICB(J)=0
      END IF
15    CONTINUE
 
C   FIND THE STRINGS OF COLUMNS THAT HAVE CB PRESENT
      JRIGHT=NXF-1
20    JLEFT=JRIGHT+1
      CALL EXTENT(1,NX,1,1,1,0,0,NXL,1,ICB,JLEFT,JRIGHT)
      IF(JLEFT.GT.NXL) GO TO 10
 
C   GET POINTS THAT DEFINE TOP OF CB
      NLEFT=2
      IF(JLEFT.GT.1) NLEFT=1
      NRIGHT=2
      IF(JRIGHT.LT.NX) NRIGHT=1
      CALL GETPTS(JLEFT,JRIGHT,K,ZXB,XMIN,XMAX,X,XPTS1,ZPTS1,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS1)
 
C   CHECK TO SEE IF LEFT AND RIGHT PINCH OUT EDGES ARE UNDERLAIN BY ZERO
C   THICKNESS LAYERS. IF SO, EXTENT PINCH OUT TO THE ADJACENT NODE RATHER
C   THAN THE CELL EDGE.
      IF(NLEFT.EQ.1) THEN
        DZ1= ZXT(JLEFT,K+1) - ZXB(JLEFT,K+1)
        DZ2= ZXT(JLEFT-1,K+1) - ZXB(JLEFT-1,K+1)
        IF(DZ1.EQ.0.0 .AND. DZ2.EQ.0.0) THEN
          XPTS1(1)= X(JLEFT-1)
          ZPTS1(1)= ZXB(JLEFT-1,K)
        END IF
      END IF
      IF(NRIGHT.EQ.1) THEN
        DZ1= ZXT(JRIGHT,K+1) - ZXB(JRIGHT,K+1)
        DZ2= ZXT(JRIGHT+1,K+1) - ZXB(JRIGHT+1,K+1)
        IF(DZ1.EQ.0.0 .AND. DZ2.EQ.0.0) THEN
          XPTS1(NPTS1)= X(JRIGHT+1)
          ZPTS1(NPTS1)= ZXB(JRIGHT+1,K)
        END IF
      END IF
 
C   GET POINTS THAT DEFINE BOTTOM OF CB (CHECK FOR PINCH-OUT POINTS)
      NLEFT=2
      IF(JLEFT.GT.1) THEN
        IF(ZXB(JLEFT-1,K)-ZXT(JLEFT-1,K+1).GT.0.0) THEN
          NLEFT=1
        ELSE
          NLEFT=0
        END IF
      END IF
 
      NRIGHT=2
      IF(JRIGHT.LT.NX) THEN
        IF(ZXB(JRIGHT+1,K)-ZXT(JRIGHT+1,K+1).GT.0.0) THEN
          NRIGHT=1
        ELSE
          NRIGHT=0
        END IF
      END IF
      CALL GETPTS(JLEFT,JRIGHT,K+1,ZXT,XMIN,XMAX,X,XPTS2,ZPTS2,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS2)
 
C   COMBINE TOP & BOTTOM INTO A SINGLE CLOSED POLYGON
      CALL COMBIN(XPTS1,ZPTS1,NPTS1,XPTS2,ZPTS2,NPTS2,XPTS,ZPTS,NPTS,
     1            MAXPTS,0,1)
C   SHADE THE POLYGON IF CB SHADING IS TURNED ON
      IF(ISHADE.EQ.1) THEN
        CALL PLOTFA(NPTS,XPTS,ZPTS)
      END IF
C   OUTLINE THE POLYGON IN ALL CASES
      CALL PLOTPL(NPTS,XPTS,ZPTS)
 
      IF(JRIGHT.EQ.NXL) GO TO 10
      GO TO 20
10    CONTINUE
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XDVLIN (J,ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NZF,NZL,
     1                   X,XMIN,XMAX,MAXPTS,NUM,ITYPE,IEDGE)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),IB(NX,NZ),XPTS(MAXPTS),
     1          ZPTS(MAXPTS),X(NX),XMIN(NX),XMAX(NX)
C
      IE=0
      IF(J.EQ.1 .AND. IEDGE.EQ.0) IE=1
      IF(J.EQ.NX .AND. IEDGE.EQ.1) IE=2
 
      IF(IEDGE.EQ.0) THEN
        XPTS(1)=XMIN(J)
        IF(J.GT.1) FAC= (XMIN(J)-X(J-1))/(X(J)-X(J-1))
      ELSE
        XPTS(1)=XMAX(J)
        IF(J.LT.NX) FAC= (XMAX(J)-X(J))/(X(J+1)-X(J))
      END IF
      XPTS(2)=XPTS(1)
 
C   FIND A CONTINUOUS BLOCK OF CELLS
      KBOT=NZF-1
40    KTOP=KBOT+1
      KBOT=KTOP
      CALL EXTENT(NZ,NX,NUM,2,ITYPE,0,0,NZL,J,IB,KTOP,KBOT)
 
C   RETURN WHEN NO MORE BLOCKS OF CELLS ARE FOUND (KTOP>NZL)
      IF(KTOP.GT.NZL) RETURN
 
C   FIND ANY INTERVENING QUASI-3D LAYERS AND BREAK THIS BLOCK OF CELLS INTO
C   PIECES SO THAT LINES DO NOT GO THROUGH THE QUASI-3D LAYERS
      K2=KTOP-1
50    K1=K2+1
      IF(K1.GT.KBOT) GO TO 40
 
C   FIND THE VERTICAL COORDINATE OF THE FIRST POINT IN THE SUB-SEGMENT
      IF(IE.GT.0) THEN
        ZPTS(1)= ZXT(J,K1)
      ELSE
        IF(IEDGE.EQ.0) THEN
          IF(K1.EQ.NZF) THEN
            ZPTS(1)= (1.0-FAC)*ZXT(J-1,K1) + FAC*ZXT(J,K1)
          ELSE IF(K1.EQ.KTOP) THEN
            DZ1=(ZXB(J,K1-1)-ZXT(J,K1))
            DZ2=(ZXB(J-1,K1-1)-ZXT(J-1,K1))
            IF(DZ1.GT.0.0 .AND. DZ2.GT.0.0) THEN
              ZPTS(1)= (1.0-FAC)*ZXT(J-1,K1) + FAC*ZXT(J,K1)
            ELSE
              ZPTS(1)= (1.0-FAC)*ZXB(J-1,K1-1) + FAC*ZXB(J,K1-1)
            END IF
          ELSE
              ZPTS(1)= (1.0-FAC)*ZXT(J-1,K1) + FAC*ZXT(J,K1)
          END IF
        ELSE IF(IEDGE.EQ.1) THEN
          IF(K1.EQ.NZF) THEN
            ZPTS(1)= (1.0-FAC)*ZXT(J,K1) + FAC*ZXT(J+1,K1)
          ELSE IF(K1.EQ.KTOP) THEN
            DZ1=(ZXB(J,K1-1)-ZXT(J,K1))
            DZ2=(ZXB(J+1,K1-1)-ZXT(J+1,K1))
            IF(DZ1.GT.0.0 .AND. DZ2.GT.0.0) THEN
              ZPTS(1)= (1.0-FAC)*ZXT(J,K1) + FAC*ZXT(J+1,K1)
            ELSE
              ZPTS(1)= (1.0-FAC)*ZXB(J,K1-1) + FAC*ZXB(J+1,K1-1)
            END IF
          ELSE
              ZPTS(1)= (1.0-FAC)*ZXT(J,K1) + FAC*ZXT(J+1,K1)
          END IF
        END IF
      END IF
 
C   FIND THE SECOND POINT IN THE SUB-SEGMENT
      DO 60 KK=K1,KBOT
      K2=KK
      IF(KK.EQ.NZ) GO TO 65
      DZ2=1.0
      DZ1=(ZXB(J,KK)-ZXT(J,KK+1))
      IF(IE.NE.1 .AND. IEDGE.EQ.0)  THEN
        DZ2=(ZXB(J-1,KK)-ZXT(J-1,KK+1))
      ELSE IF(IE.NE.2 .AND. IEDGE.EQ.1) THEN
        DZ2=(ZXB(J+1,KK)-ZXT(J+1,KK+1))
      END IF
      IF(DZ1.GT.0.0 .AND. DZ2.GT.0.0) GO TO 65
60    CONTINUE
65    CONTINUE
 
C   CALCULATE THE VERTICAL COORDINATE OF THE SECOND POINT IN THE
C   SUB-SEGMENT
      IF(IE.GT.0) THEN
        ZPTS(2)= ZXB(J,K2)
      ELSE
        IF(IEDGE.EQ.0) THEN
          ZPTS(2)= (1.0-FAC)*ZXB(J-1,K2) + FAC*ZXB(J,K2)
        ELSE IF(IEDGE.EQ.1) THEN
          ZPTS(2)= (1.0-FAC)*ZXB(J,K2) + FAC*ZXB(J+1,K2)
        END IF
      END IF
 
C   DRAW VERTICAL SUB-SEGMENT
      CALL PLOTPL(2,XPTS,ZPTS)
      GO TO 50
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XIGLIN (ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1                   X,XMIN,XMAX,MAXPTS)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),IB(NX,NZ),XPTS(MAXPTS),
     1          ZPTS(MAXPTS),X(NX),XMIN(NX),XMAX(NX)
C
C  CONSTRUCT LATERAL INTERIOR GRID LINES
C
      NZFP1=NZF+1
      DO 10 K=NZFP1,NZL
      JRIGHT=NXF-1
20    JLEFT=JRIGHT+1
      CALL EXTENT(NZ,NX,2,1,2,0,0,NXL,K,IB,JLEFT,JRIGHT)
      IF(JLEFT.GT.NXL) GO TO 10
C   COMPUTE POINTS THAT DEFINE THE POLYGON
      NLEFT=2
      NRIGHT=2
      IF(JLEFT.GT.1) NLEFT=1
      IF(JRIGHT.LT.NX) NRIGHT=1
      CALL GETPTS(JLEFT,JRIGHT,K-1,ZXB,XMIN,XMAX,X,XPTS,ZPTS,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS)
C   DRAW LATERAL GRID LINE SEGMENT
      CALL PLOTPL(NPTS,XPTS,ZPTS)
      IF(JRIGHT.EQ.NXL) GO TO 10
      GO TO 20
10    CONTINUE
 
C   CONSTRUCT VERTICAL INTERIOR GRID LINES
      NXFP1=NXF+1
      DO 30 J=NXFP1,NXL
      CALL XDVLIN(J,ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NZF,NZL,
     1            X,XMIN,XMAX,MAXPTS,2,2,0)
30    CONTINUE
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XOGZ(ZXT,ZXB,IB,IBM,XPTS,ZPTS,NX,NZ,NXF,
     1       NXL,NZF,NZL,X,XMIN,XMAX,IGEOL,NGEOL,MAXPTS,ISGZ,ICSGZ)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),IB(NX,NZ),IBM(NX,NZ),
     1 XPTS(MAXPTS),ZPTS(MAXPTS),X(NX),XMIN(NX),XMAX(NX),
     2 IGEOL(2*NGEOL)
C
C   LOOP THROUGH ZONES
      DO 100 IZONE=1,NGEOL
      ISHERE=0
      DO 105 K=NZF,NZL
      DO 105 J=NXF,NXL
      IF(IB(J,K).EQ.IZONE) THEN
      ISHERE=1
      GO TO 106
      END IF
105   CONTINUE
106   CONTINUE
 
C   SKIP IF ZONE IS NOT PRESENT IN CROSS SECTION, THE SHADE PATTERN
C   IS LESS THAN 0, OR THE SHADE PATTERN IS SOLID FILL
      IF(ISHERE.EQ.0) GO TO 100
      IF(IGEOL(2*IZONE).LT.0) GO TO 100
      IF(ISGZ.EQ.2 .AND. ICSGZ.EQ.0) GO TO 100
      DO 107 K=1,NZ
      DO 107 J=1,NX
      IF(IB(J,K).EQ.IZONE) THEN
        IBM(J,K)=1
      ELSE
        IBM(J,K)=0
      END IF
107   CONTINUE
 
      CALL XOZONE(ZXT,ZXB,IBM,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,X,XMIN,
     1  XMAX,MAXPTS)
 
100   CONTINUE
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XOZONE (ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1                   X,XMIN,XMAX,MAXPTS)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),IB(NX,NZ),XPTS(MAXPTS),
     1          ZPTS(MAXPTS),X(NX),XMIN(NX),XMAX(NX)
C
C  FIND BOUNDARY SEGMENTS ALONG TOP ROW AND BOTTOM ROW OF PLOT
C
      DO 1 N=1,2
      IF(N.EQ.1) K=NZF
      IF(N.EQ.2) K=NZL
      JRIGHT=NXF-1
2     JLEFT=JRIGHT+1
      JRIGHT=JLEFT
      CALL EXTENT(NZ,NX,1,1,1,0,0,NXL,K,IB,JLEFT,JRIGHT)
      IF(JLEFT.GT.NXL) GO TO 1
 
C   COMPUTE POINTS THAT DEFINE THE POLYGON
      NLEFT=2
      NRIGHT=2
      IF(JLEFT.GT.1) NLEFT=1
      IF(JRIGHT.LT.NX) NRIGHT=1
      IF(N.EQ.1) THEN
      CALL GETPTS(JLEFT,JRIGHT,K,ZXT,XMIN,XMAX,X,XPTS,ZPTS,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS)
      ELSE
      CALL GETPTS(JLEFT,JRIGHT,K,ZXB,XMIN,XMAX,X,XPTS,ZPTS,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS)
      END IF
C   DRAW LATERAL BOUNDARY SEGMENT FOR ROW NZF OR ROW NZL
      CALL PLOTPL(NPTS,XPTS,ZPTS)
      IF(JRIGHT.EQ.NXL) GO TO 1
      GO TO 2
1     CONTINUE
 
C   FIND BOUNDARY SEGMENTS ALONG ALL THE OTHER ROWS
      NZFP1=NZF+1
      IF(NZFP1.LE.NZL) THEN
      DO 10 K=NZFP1,NZL
      JRIGHT=NXF-1
20    JLEFT=JRIGHT+1
      JRIGHT=JLEFT
      CALL EXTENT(NZ,NX,2,1,1,0,0,NXL,K,IB,JLEFT,JRIGHT)
      IF(JLEFT.GT.NXL) GO TO 10
      NLEFT=2
      NRIGHT=2
      IF(JLEFT.GT.1) NLEFT=1
      IF(JRIGHT.LT.NX) NRIGHT=1
      CALL GETPTS(JLEFT,JRIGHT,K-1,ZXB,XMIN,XMAX,X,XPTS,ZPTS,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS)
C   DRAW LATERAL BOUNDARY SEGMENT
      CALL PLOTPL(NPTS,XPTS,ZPTS)
      IF(JRIGHT.EQ.NXL) GO TO 10
      GO TO 20
10    CONTINUE
      END IF
 
C   DRAW VERTICAL BOUNDARY SEGMENTS
C    CONSTRUCT THE VETICAL BOUNDARIES FOR THE FIRST AND LAST COLUMNS
      DO 25 N=1,2
      IF(N.EQ.1) THEN
      J=NXF
      IEDGE=0
      ELSE
      J=NXL
      IEDGE=1
      END IF
      CALL XDVLIN(J,ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NZF,NZL,
     1                   X,XMIN,XMAX,MAXPTS,1,1,IEDGE)
25    CONTINUE
 
C    CONSTRUCT VERTICAL ACTIVE GRID BOUNDARIES FOR ALL OTHER COLUMNS
      NXFP1=NXF+1
      DO 30 J=NXFP1,NXL
      CALL XDVLIN(J,ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NZF,NZL,
     1                   X,XMIN,XMAX,MAXPTS,2,1,0)
30    CONTINUE
 
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XSGZ (ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1 X,XMIN,XMAX,IGEOL,NGEOL,XPTS1,ZPTS1,XPTS2,ZPTS2,MAXPTS,ISGZ)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),IB(NX,NZ),XPTS(2*MAXPTS+1),
     1 ZPTS(2*MAXPTS+1),X(NX),XMIN(NX),XMAX(NX),XPTS1(MAXPTS),
     2 ZPTS1(MAXPTS),XPTS2(MAXPTS),ZPTS2(MAXPTS),IGEOL(2*NGEOL)
C
      CALL QFAST(IFSOLD)
 
C   LOOP THROUGH ZONES
      DO 100 IZONE=1,NGEOL
      ISHERE=0
      DO 105 K=NZF,NZL
      DO 105 J=NXF,NXL
      IF(IB(J,K).EQ.IZONE) THEN
      ISHERE=1
      GO TO 106
      END IF
105   CONTINUE
106   CONTINUE
 
C   SKIP IF ZONE IS NOT PRESENT IN CROSS SECTION OR IF ZONE SHADE PATTERN
C   IS LESS THAN OR EQUAL TO 0
      CALL GSFACI(IGEOL(2*IZONE-1))
      IF(ISHERE.EQ.0 .OR. IGEOL(2*IZONE).LE.0) GO TO 100
      NFSTYL=IGEOL(2*IZONE)
      IF(ISGZ.EQ.3) THEN
        CALL SFAST(NFSTYL)
      ELSE IF(ISGZ.EQ.2) THEN
        CALL SFAST(7)
      END IF
C   LOOP THROUGH LAYERS
      DO 110 K=NZF,NZL
C   FIND STARTING COLUMN FOR A BLOCK OF CELLS
      JRIGHT=NXF-1
20    JLEFT=JRIGHT+1
      CALL EXTENT(NZ,NX,1,1,8,0,IZONE,NXL,K,IB,JLEFT,JRIGHT)
      IF(JLEFT.GT.NXL) GO TO 110
 
C   COMPUTE AND SHADE POLYGON, USING MULTIPLE SEGMENTS TO ACCOUNT FOR
C   PINCH-OUT CONFINING LAYERS IF NECESSARY
 
      CALL XSZONE(JLEFT,JRIGHT,K,ZXT,ZXB,XMIN,XMAX,X,XPTS,ZPTS,
     1 XPTS1,ZPTS1,XPTS2,ZPTS2,NX,NZ,NZF,MAXPTS)
 
      IF(JRIGHT.EQ.NXL) GO TO 110
      GO TO 20
110   CONTINUE
 
100   CONTINUE
      CALL SFAST(IFSOLD)
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XSZONE(JLEFT,JRIGHT,K,ZXT,ZXB,XMIN,XMAX,X,XPTS,ZPTS,
     1 XPTS1,ZPTS1,XPTS2,ZPTS2,NX,NZ,NZF,MAXPTS)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),XPTS(2*MAXPTS+1),
     1 ZPTS(2*MAXPTS+1),X(NX),XMIN(NX),XMAX(NX),XPTS1(MAXPTS),
     2 ZPTS1(MAXPTS),XPTS2(MAXPTS),ZPTS2(MAXPTS)
C
      JR=JLEFT-1
10    JL=JR+1
      JR=JL
      NLPNCH=0
      NRPNCH=0
      IF(JL.GT.1 .AND. K.GT.NZF) THEN
        CALL PINCH(ZXB(JL-1,K),ZXT(JL-1,K),ZXB(JL,K),ZXT(JL,K),
     1             ZXB(JL-1,K-1),ZXB(JL,K-1),NLPNCH)
      ELSE IF(JL.GT.JLEFT) THEN
        NLPNCH=1
      END IF
      DO 15 J=JL,JRIGHT
        JR=J
        IF(J.LT.NX .AND. K.GT.NZF) THEN
          CALL PINCH(ZXB(J,K),ZXT(J,K),ZXB(J+1,K),ZXT(J+1,K),
     1               ZXB(J,K-1),ZXB(J+1,K-1),NRPNCH)
          IF(NRPNCH.EQ.1) GO TO 16
        END IF
15    CONTINUE
16    CONTINUE
      NLEFT=2
      NRIGHT=2
      IF(JL.GT.1) NLEFT=1
      IF(JR.LT.NX) NRIGHT=1
      CALL GETPTS(JL,JR,K,ZXT,XMIN,XMAX,X,XPTS1,ZPTS1,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS1)
C
      IF(NLPNCH.GT.0) THEN
        FAC= (XMAX(JL-1)-X(JL-1))/(X(JL)-X(JL-1))
        ZPTS1(1)= (1.0-FAC)*ZXB(JL-1,K-1) + FAC*ZXB(JL,K-1)
      END IF
      IF(NRPNCH.GT.0) THEN
        FAC= (XMAX(JR)-X(JR))/(X(JR+1)-X(JR))
        ZPTS1(NPTS1)= (1.0-FAC)*ZXB(JR,K-1) + FAC*ZXB(JR+1,K-1)
      END IF
      NLEFT=2
      NRIGHT=2
      IF(JL.GT.1) NLEFT=1
      IF(JR.LT.NX) NRIGHT=1
      CALL GETPTS(JL,JR,K,ZXB,XMIN,XMAX,X,XPTS2,ZPTS2,NX,NZ,
     1            MAXPTS,NLEFT,NRIGHT,NPTS2)
      CALL COMBIN(XPTS1,ZPTS1,NPTS1,XPTS2,ZPTS2,NPTS2,XPTS,ZPTS,NPTS,
     1            MAXPTS,0,1)
C   SHADE THE POLYGON
      CALL PLOTFA(NPTS,XPTS,ZPTS)
      IF(JR.LT.JRIGHT) GO TO 10
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE XSIAC (ZXT,ZXB,IB,XPTS,ZPTS,NX,NZ,NXF,NXL,NZF,NZL,
     1 X,XMIN,XMAX,XPTS1,ZPTS1,XPTS2,ZPTS2,MAXPTS)
C
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),IB(NX,NZ),XPTS(2*MAXPTS+1),
     1 ZPTS(2*MAXPTS+1),X(NX),XMIN(NX),XMAX(NX),XPTS1(MAXPTS),
     2 ZPTS1(MAXPTS),XPTS2(MAXPTS),ZPTS2(MAXPTS)
C
 
      DO 110 K=NZF,NZL
C   FIND STARTING COLUMN FOR A BLOCK OF CELLS
      JRIGHT=NXF-1
20    JLEFT=JRIGHT+1
      CALL EXTENT(NZ,NX,1,1,8,0,1,NXL,K,IB,JLEFT,JRIGHT)
      IF(JLEFT.GT.NXL) GO TO 110
 
C   COMPUTE AND SHADE POLYGON, USING MULTIPLE SEGMENTS TO ACCOUNT FOR
C   PINCH-OUT CONFINING LAYERS IF NECESSARY
 
      CALL XSZONE(JLEFT,JRIGHT,K,ZXT,ZXB,XMIN,XMAX,X,XPTS,ZPTS,
     1 XPTS1,ZPTS1,XPTS2,ZPTS2,NX,NZ,NZF,MAXPTS)
 
      IF(JRIGHT.EQ.NXL) GO TO 110
      GO TO 20
110   CONTINUE
 
100   CONTINUE
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE EXTENT(NRMAX,NCMAX,NUM,IDIR,ITYPE,NVAL1,NVAL2,
     1                  NLAST,K,IBOUND,N1,N2)
      DIMENSION IBOUND(NCMAX,NRMAX)
C
      IB1=0
      N2=N1
5     IF(N1.GT.NLAST) GO TO 20
C
      IF(IDIR.EQ.1) THEN
      IF(NUM.EQ.2) IB1= IBOUND(N1,K-1)
      IB2= IBOUND(N1,K)
      ELSE
      IF(NUM.EQ.2) IB1= IBOUND(K-1,N1)
      IB2= IBOUND(K,N1)
      END IF
C
      CALL MATCH(ITYPE,IB1,IB2,NVAL1,NVAL2,ISTRUE)
      IF(ISTRUE.EQ.1) GO TO 10
      N1=N1+1
      GO TO 5
10    CONTINUE
      N2=N1
15    N2=N2+1
      IF(N2.GT.NLAST) THEN
      N2=NLAST
      GO TO 20
      END IF
C
      IF(IDIR.EQ.1) THEN
      IF(NUM.EQ.2) IB1= IBOUND(N2,K-1)
      IB2= IBOUND(N2,K)
      ELSE
      IF(NUM.EQ.2) IB1= IBOUND(K-1,N2)
      IB2= IBOUND(K,N2)
      END IF
C
      CALL MATCH(ITYPE,IB1,IB2,NVAL1,NVAL2,ISTRUE)
      IF(ISTRUE.EQ.1) GO TO 15
      N2=N2-1
C
20    CONTINUE
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE MATCH(ITYPE,IB1,IB2,NVAL1,NVAL2,ISTRUE)
C
      ISTRUE=0
C
      I1=IABS(IB1)
      I2=IABS(IB2)
      IPROD=I1*I2
      ISUM=I1+I2
C
      IF(ITYPE.EQ.1) THEN
        IF(IPROD.EQ.0.AND.ISUM.NE.0) ISTRUE=1
      ELSE IF(ITYPE.EQ.2) THEN
        IF(IPROD.NE.0) ISTRUE=1
      ELSE IF(ITYPE.EQ.3) THEN
        IF(IPROD.EQ.0.AND.ISUM.EQ.0) ISTRUE=1
      ELSE IF(ITYPE.EQ.4) THEN
        N=0
        IF(I1.EQ.NVAL1.OR.I2.EQ.NVAL1) N=1
        IF(I1.NE.I2) N=N+1
        IF(N.EQ.2) ISTRUE=1
      ELSE IF(ITYPE.EQ.5) THEN
        IF(I1.EQ.NVAL1.AND.I2.EQ.NVAL1) ISTRUE=1
      ELSE IF(ITYPE.EQ.6) THEN
        IF(I1.NE.0.AND.I2.EQ.NVAL1) ISTRUE=1
      ELSE IF(ITYPE.EQ.7) THEN
        IF(I1.EQ.NVAL1.AND.I2.NE.0) ISTRUE=1
      ELSE IF(ITYPE.EQ.8) THEN
        IF(I1.EQ.NVAL1.AND.I2.EQ.NVAL2) ISTRUE=1
      END IF
C
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE PINCH(ZBLK,ZTLK,ZBRK,ZTRK,ZBLK1,ZBRK1,NPINCH)
      NPINCH=0
      DZ1= ZBLK1-ZTLK
      DZ2= ZBRK1-ZTRK
      I1=0
      I2=1
      IF(DZ1.NE.0.0 .OR. DZ2.NE.0.0) I1=1
      IF(DZ1.EQ.0.0 .OR. DZ2.EQ.0.0) I2=0
      IF(I1.NE.0 .AND. I2.EQ.0) NPINCH=1
      DZ1=ZTLK-ZBLK
      DZ2=ZTRK-ZBRK
      IF(DZ1.EQ.0.0 .AND. DZ2.EQ.0.0) NPINCH=0
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE TRMPTS (NP,X,Y,NPTRM)
      DIMENSION X(NP),Y(NP)
 
      IF(NP.LE.4) THEN
        NPTRM=NP
        RETURN
      END IF
 
      NPM1=NP-1
      NPTRM=2
      ISKIP=0
      DO 10 N=3,NPM1
      IF(Y(N).NE.Y(NPTRM)) THEN
        IF(ISKIP.EQ.1) THEN
          NPTRM=NPTRM+2
          X(NPTRM-1)=X(N-1)
          Y(NPTRM-1)=Y(N-1)
          X(NPTRM)=X(N)
          Y(NPTRM)=Y(N)
        ELSE
          NPTRM=NPTRM+1
          X(NPTRM)=X(N)
          Y(NPTRM)=Y(N)
        END IF
        ISKIP=0
      ELSE IF(Y(N).EQ.Y(NPTRM) .AND. N.LT.NPM1) THEN
        ISKIP=1
      ELSE IF(N.EQ.NPM1) THEN
        NPTRM=NPTRM+1
        X(NPTRM)=X(N)
        Y(NPTRM)=Y(N)
      END IF
10    CONTINUE
      NPTRM=NPTRM+1
      X(NPTRM)=X(NP)
      Y(NPTRM)=Y(NP)
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE TOPWT(TOP,BOT,NX,IREV,HEAD,HNOFLO,HDRY,NCOL,NROW,NLAY,
     1                 ISLICE,IVIEW,BUFF)
      DIMENSION TOP(NX),BOT(NX),BUFF(NX),HEAD(NCOL,NROW,NLAY)
 
C... SET BUFF TO HEAD IN 2D SLICE. REVERSE DIRECTION IF NECESSARY.
      IF(IVIEW.EQ.2) THEN
        IF(IREV.EQ.0) THEN
          DO 10 N=1,NX
10        BUFF(N)=HEAD(ISLICE,N,1)
        ELSE
          DO 11 N=1,NX
11        BUFF(N)=HEAD(ISLICE,NX+1-N,1)
        END IF
      ELSE IF(IVIEW.EQ.3) THEN
        IF(IREV.EQ.0) THEN
          DO 20 N=1,NX
20        BUFF(N)=HEAD(N,ISLICE,1)
        ELSE
          DO 21 N=1,NX
21        BUFF(N)=HEAD(NX+1-N,ISLICE,1)
        END IF
      END IF
 
C... SET TOP ARRAY
      DO 30 N=1,NX
      IF(N.GT.1) HM=H
      H=BUFF(N)
      IF(N.LT.NX) HP=BUFF(N+1)
      IF(H.EQ.HDRY) THEN
        TOP(N)=BOT(N)
      ELSE IF(H.EQ.HNOFLO) THEN
        LEFT=0
        IRIGHT=0
        IF(N.GT.1) THEN
          IF(HM.NE.HNOFLO .AND. HM.NE.HDRY .AND. HM.GT.BOT(N)) LEFT=1
        END IF
        IF(N.LT.NX) THEN
          IF(HP.NE.HNOFLO .AND. HP.NE.HDRY .AND. HP.GT.BOT(N)) IRIGHT=1
        END IF
        IF(LEFT.EQ.0 .AND. IRIGHT.EQ.0) THEN
          TOP(N)=BOT(N)
        ELSE IF(LEFT.EQ.0 .AND. IRIGHT.EQ.1) THEN
          TOP(N)=HP
        ELSE IF(LEFT.EQ.1 .AND. IRIGHT.EQ.0) THEN
          TOP(N)=HM
        ELSE IF(LEFT.EQ.1 .AND. IRIGHT.EQ.1) THEN
          TOP(N)=(HM+HP)/2.0
        END IF
      ELSE
        TOP(N)=H
      END IF
30    CONTINUE
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE NOTATE (XMIN,XMAX,YMIN,YMAX,PX,PY,JUNITS,TITLE,VX,
     1 IVIEW,XLEFT,YBOT,PSCFAC)
      DIMENSION XA(3),YA(3)
      CHARACTER*5 JU1
      CHARACTER*7 JU2
      CHARACTER*80 TITLE
      CHARACTER*25 EXAG
      CHARACTER*20 STRING
      CHARACTER*40 CONCAT
C
      JU1= ' FEET'
      JU2= ' METERS'
      EXAG= 'VERTICAL EXAGGERATION IS '
      YPY= (YMAX-YMIN)/PY
      XMID= 0.5*XMIN + 0.5*XMAX
c      XTITLE= XMID - PSCFAC*(XMAX-XMIN)/2.0
      XTITLE= XMID - (XMAX-XMIN)/2.0
      X= 0.2*(XMAX-XMIN)
      XL10= ALOG10(X)
      IXL10= IFIX(XL10)
      XX= FLOAT(IXL10)
      XMAN= XL10-XX
      XXX= 10.0**(XMAN)
      IXXX= IFIX(XXX)
      XINC= 10.0**(IXL10)
      NINC= IXXX
      YP5= YBOT-(YPY*0.20*PY)
      YP4= YBOT-(YPY*0.05*PY)
      YP3= YBOT-(YPY*0.058*PY)
      YP2= YBOT-(YPY*0.083*PY)
      YP1= YBOT-(YPY*0.133*PY)
      CALL GTX(XTITLE,YP5,TITLE)
      XA(1)= XLEFT
      XA(2)=XLEFT
      XA(3)=XLEFT
      YA(1)=YP3
      YA(2)=YP2
      YA(3)=YP2
      CALL PLOTPL(3,XA,YA)
      XA(1)=XLEFT
      YA(1)=YP2
      YA(2)=YP2
      YA(3)=YP3
      DO 10  N=1,NINC
      XA(2)=XLEFT + (XINC*N)
      XA(3)=XA(2)
      CALL PLOTPL(3,XA,YA)
      XA(1)=XA(2)
10    CONTINUE
      INUM=0
      ZTMP=INUM
      CALL NUMCNV(ZTMP,-1,STRING,NCHARS)
      CALL GTX(XLEFT,YP4,STRING(1:NCHARS))
      IF (NINC.GT.1) THEN
      XVAL= XLEFT + XINC
      CALL NUMCNV(XINC,-1,STRING,NCHARS)
      CALL GTX(XVAL,YP4,STRING(1:NCHARS))
      END IF
      XVAL= XINC*NINC
      CALL NUMCNV(XVAL,-1,STRING,NCHARS)
      XVAL=XVAL + XLEFT
      IF(JUNITS.EQ.1) THEN
      STRING=STRING(1:NCHARS)//JU1
      NCHARS=NCHARS+5
      CALL GTX(XVAL,YP4,STRING(1:NCHARS))
      ELSE
      CONCAT=STRING(1:NCHARS)//JU2
      NCHARS=NCHARS+7
      CALL GTX(XVAL,YP4,CONCAT(1:NCHARS))
      END IF
      IF (IVIEW.NE.1) THEN
      IF(VX.GE.1.0) CALL NUMCNV(VX,1,STRING,NCHARS)
      IF(VX.LT.1.0) CALL NUMCNV(VX,4,STRING,NCHARS)
      CONCAT=EXAG//STRING(1:NCHARS)
      NCHARS=25+NCHARS
      CALL GTX(XLEFT,YP1,CONCAT(1:NCHARS))
      END IF
      YP3S= YP2 + (YP3-YP2)/2.0
      IF(NINC.LE.3) THEN
      XINC=XINC/5.0
      XA(1)=XLEFT
      YA(1)= YP2
      YA(2)=YP2
      YA(3)= YP3S
      DO 20  N=1,4
      XA(2)= XLEFT + (XINC*N)
      XA(3)= XA(2)
      CALL PLOTPL(3,XA,YA)
      XA(1)=XA(2)
20    CONTINUE
      END IF
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE GETCPT(I,K,ZXT,ZXB,NX,NZ,YP,NP)
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),YP(NP)
C
      IF(I.GT.1) THEN
        YP(1)= (ZXT(I-1,K)+ZXT(I,K))/2.0
        YP(6)= (ZXB(I-1,K)+ZXB(I,K))/2.0
      ELSE
        YP(1)=ZXT(I,K)
        YP(6)=ZXB(I,K)
      END IF
      IF(I.LT.NX) THEN
        YP(3)= (ZXT(I+1,K)+ZXT(I,K))/2.0
        YP(4)= (ZXB(I+1,K)+ZXB(I,K))/2.0
      ELSE
        YP(3)=ZXT(I,K)
        YP(4)=ZXB(I,K)
      END IF
      YP(2)=ZXT(I,K)
      YP(5)=ZXB(I,K)
      YP(7)=YP(1)
C
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE DLEGND (NGUA,WINLEG,LMESS,HGHT,CHSPAC,NLMESS,TLEGND,
     1                   IGEOL,NGEOL,IFONT,ISGZ)
      CHARACTER*30 LMESS(NLMESS)
      CHARACTER*50 TLEGND
      DIMENSION NGUA(NLMESS),IGEOL(NGEOL)
      DIMENSION WINLEG(4),X(5),Y(5)
 
C
      D=NLMESS
      OFFSET=(WINLEG(4)-WINLEG(3))/(D+1.0)
      DXY= OFFSET/1.15
      HTXT= 0.2*DXY
      CALL SETTXT(IFONT,2,HTXT,CHSPAC)
 
      CALL GQTXAL(IERR,IHOLD,IVOLD)
      CALL QFAST(IFOLD)
      CALL GQFACI(IERR,IFCOLD)
      CALL GQPLCI(IERR,ILCOLD)
      CALL GSPLCI(1)
      XTXT= WINLEG(1)
      CALL GSTXAL(1,3)
 
C--- INITIALIZE THE COORDINATES OF THE LEGEND BOXES
      X(1)= WINLEG(1)
      X(2)= X(1) + DXY
      X(3)= X(2)
      X(4)= X(1)
      X(5)= X(1)
 
      YMID=(WINLEG(3)+WINLEG(4)-OFFSET)/2.0
      COWNT=0.0
      DO 10 N=1,NLMESS
      IF(NGUA(N).EQ.0) GO TO 15
      IF(IGEOL(2*NGUA(N)) .LE. 0) GO TO 10
      COWNT=COWNT+1.0
10    CONTINUE
15    CONTINUE
 
      Y(3)=YMID + (OFFSET*COWNT/2.0)
      Y(4)=Y(3)
      Y(1)=Y(4)-DXY
      Y(2)=Y(1)
      Y(5)=Y(1)
 
C--- DISPLAY LEGEND TITLE IF THERE IS ONE
      IF(TLEGND .NE. ' ') THEN
        YTXT=Y(3) + (OFFSET/2.0)
        CALL GTX(XTXT,YTXT,TLEGND)
      END IF
 
C--- LOOP THROUGH LEGEND ENTRIES AND PLOT THEM
      XTXT= XTXT + OFFSET
      DO 20 N=1,NLMESS
      IF(NGUA(N) .EQ. 0) GO TO 30
      IF(IGEOL(2*NGUA(N)) .LE. 0) GO TO 30
      CALL GSFACI(IGEOL(2*NGUA(N)-1))
      NFSTYL= IGEOL(2*NGUA(N))
      IF(ISGZ .EQ. 3) THEN
        CALL SFAST(NFSTYL)
      ELSE IF(ISGZ .EQ. 2) THEN
        CALL SFAST(7)
      END IF
      CALL PLOTFA(5,X,Y)
      CALL PLOTPL(5,X,Y)
      YTXT= (Y(2)+Y(3))/2.0
      CALL GTX(XTXT,YTXT,LMESS(N))
      DO 21 I=1,5
21    Y(I)= Y(I) - OFFSET
20    CONTINUE
30    CONTINUE
 
C--- RESET OLD PARAMETER VALUES
      CALL GSTXAL(IHOLD,IVOLD)
      CALL SFAST(IFOLD)
      CALL GSFACI(IFCOLD)
      CALL GSPLCI(ILCOLD)
      CALL SETTXT(IFONT,2,HGHT,CHSPAC)
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE WTDRAW(H,Y,LAYCON,NCOL,NROW,NLAY,IVIEW,IX,IXYDIR,
     1                  X,NX,HNOFLO,HDRY,KOLOR,VEX,IWTLIN)
      DIMENSION H(NCOL,NROW,NLAY),LAYCON(NLAY),X(NX),Y(NX)
 
      IFIRST=1
      ILAST=NX
      call gseltr(2)
      HNFLOX= HNOFLO*VEX
      IREV=0
      IF(IVIEW.EQ.2 .AND. IXYDIR.EQ.0) IREV=1
      IF(IVIEW.EQ.3 .AND. IXYDIR.EQ.1) IREV=1
 
C--- SEARCH THE HEAD ARRAY AND LOAD THE WATER TABLE PROFILE INTO THE Y ARRAY
      DO 10 N=1,NX
        IF(IREV.EQ.0) THEN
          NN=N
        ELSE
          NN=NX+1-N
        END IF
        IF(IVIEW .EQ. 2) THEN
          JCOL=IX
          IROW=NN
        ELSE IF(IVIEW .EQ. 3) THEN
          JCOL=NN
          IROW=IX
        ELSE
          RETURN
        END IF
          Y(N)=HNFLOX
          DO 15 K=1,NLAY
          HEAD=H(JCOL,IROW,K)
          IF(LAYCON(K).LE.0) GO TO 16
          IF(HEAD.EQ.HNOFLO .OR. HEAD.EQ.HDRY) GO TO 15
          Y(N)=HEAD*VEX
          GO TO 16
15        CONTINUE
16      CONTINUE
10    CONTINUE
 
C--- SWITCH MIN AND MAX GRID COORDINATES IF SECTION IS REVERSED
      IF(IREV.EQ.0) THEN
        N1=IFIRST
        N2=ILAST
      ELSE
        N2=NX+1-IFIRST
        N1=NX+1-ILAST
      END IF
 
C--- SET POLYLINE COLOR AND LINE STYLE. SAVE OLD VALUES OF COLOR AND STYLE
      CALL GQPLCI(IERR,ICOLD)
      CALL GQLN(IERR,ISOLD)
      CALL GSPLCI(KOLOR)
      CALL GSLN(IWTLIN)
 
      I=N1
20    IF(I.EQ.N2) GO TO 30
C--- FIND A STARTING POINT FOR A POLYLINE SEGMENT
      II=I
      DO 25 N=II,N2
        IF(Y(N) .NE. HNFLOX) THEN
          I=N
          GO TO 26
        END IF
25    CONTINUE
      GO TO 30
26    CONTINUE
 
C--- FIND OUT HOW MANY POINTS ARE IN THE POLYLINE SEGMENT
      KOUNT=0
      DO 27 N=I,N2
        IF(Y(N) .EQ. HNFLOX) GO TO 28
        KOUNT=KOUNT+1
27    CONTINUE
28    CONTINUE
C--- IF KOUNT=0, SOMETHING IS WRONG, SO BAIL OUT NOW
      IF(KOUNT .EQ. 0) GO TO 30
C--- PLOT THE POLYLINE SEGMENT IF IT HAS 2 OR MORE VERTICES
      IF(KOUNT .GT. 1) CALL PLOTPL(KOUNT,X(I),Y(I))
C--- INCREMENT I AND START SEARCHING FOR ANOTHER POLYLINE SEGMENT
      I=I+KOUNT
      GO TO 20
30    CONTINUE
 
C--- RESET POLYLINE COLOR AND STYLE
      CALL GSPLCI(ICOLD)
      CALL GSLN(ISOLD)
      call gseltr(1)
      RETURN
      END
