C MODPATH-PLOT Version 4.00 (V4, Release 1, 2-2000)
C  Changes to work with MODFLOW-2000
C
C MODPATH-PLOT Version 3.00 (V3, Release 2, 5-99)
C Changes:
C   Bug Fixes:
C     1. Subroutine HEDINP was modified to correctly read heads from
C        the MODFLOW head output file when head is saved as a single
C        2D cross section using the MODFLOW-96 option, XSECTION.
C Previous release: MODPATH-PLOT Version 3.00 (V3, Release 1, 9-94)
C***** SUBROUTINES *****
C     DATIN
C     GETGZ
C     HEDINP
C     BRECT
C     CBFHED
C     NEWIXA
C     NEWRXA
C     GUADAT
C***********************
 
C***** SUBROUTINE *****
      SUBROUTINE DATIN (LAYCON,NCON,BUFF,IBUFF,HEAD,XMX,XMN,YMX,YMN,
     1DELR,DELC,DELZ,DELZCB,ZTOP,ZBOT,ZMN,ZMX,XLOC,YLOC,
     2IBOUND,IUNIT,NCOL,NROW,NLAY,NUNIT,NZDIM,IGRID,NCBL,IU,IUSUM,IPER,
     3ISTP,IVIEW,ZXT,ZXB,IBX,IGZ,NIGZ,NX,IXTYPE,IXDIR,IYDIR,IUCBF,
     4PERLEN,TIMX,NUMTS,NPER,ISS,HDRY,HNOFLO,IXREAD,ISLICE,IBPZON,
     5ITYPE,LMESS,NLMESS,NGUA,TLEGND,REFTIM,TBEGIN)
C     ------------------------------------------------------------------
C
      CHARACTER*24 ANAME
      CHARACTER*80 LINE
      CHARACTER*30 LMESS(NLMESS)
      CHARACTER*50 TLEGND
      DIMENSION LAYCON(NLAY),NCON(NLAY),DELR(NCOL),DELC(NROW),DELZ(NLAY)
     1,DELZCB(NLAY),XMX(NCOL),YMX(NROW),ZTOP(NZDIM),ZBOT(NZDIM),
     2HEAD(NCOL,NROW,NLAY),IBOUND(NCOL,NROW,NLAY),XMN(NCOL),YMN(NROW),
     4IUNIT(NUNIT),ZMN(NLAY),ZMX(NLAY),XLOC(NCOL),YLOC(NROW),
     5BUFF(NCOL,NROW),ZXT(NIGZ),ZXB(NIGZ),IBX(NX,NLAY),IGZ(NIGZ),
     6PERLEN(NPER),TIMX(NPER),NUMTS(NPER),IBUFF(NCOL,NROW,NLAY),
     7IBPZON(NCOL,NROW,NLAY),NGUA(NLMESS)
C     ------------------------------------------------------------------
C
      IUIGZ=IUNIT(15)
C
      IF(IVIEW.EQ.1) THEN
        IYDIR=0
        IXDIR=0
      END IF
 
      WRITE(IUSUM,5000)
      IF(ISS.EQ.0) THEN
        WRITE(IUSUM,5030) NPER
5030    FORMAT(' TRANSIENT SIMULATION WITH',I4,' STRESS PERIODS')
      ELSE
        WRITE(IUSUM,*) ' STEADY STATE SIMULATION'
      END IF
      WRITE(IUSUM,5000)
5000  FORMAT('  ')
      WRITE(IUSUM,5010) NCOL,NROW,NLAY,NCBL
5010  FORMAT(I5,' COLUMNS',I5,' ROWS',I5,' LAYERS',I5,' CONFINING LAYERS
     1')
      WRITE(IUSUM,5020) IGRID
5020  FORMAT(' IGRID (GRID TYPE CODE) IS',I2)
      WRITE(IUSUM,5025) HNOFLO,HDRY
5025  FORMAT(' HNOFLO = ',E12.5,5X,'HDRY = ',E12.5)
C
C  WRITE OUT LAYER TYPE CODES
C
      WRITE(IUSUM,5000)
      WRITE(IUSUM,*) 'LAYCON (LAYER TYPE CODES):'
      WRITE(IUSUM,5060) (LAYCON(N),N=1,NLAY)
5060   FORMAT(25I3)
C
C
C  DELR, GRID SPACING ALONG A ROW (X-DIRECTION)
C
      IF(IXDIR.EQ.0) THEN
        XMX(1)=DELR(1)
        XMN(1)=0.0
        XLOC(1)=DELR(1)/2.0
        DO 30 J=2,NCOL
        XMN(J)=XMX(J-1)
        XMX(J)=XMX(J-1)+DELR(J)
        XLOC(J)=(XMN(J)+XMX(J))/2.0
30      CONTINUE
      ELSE
        XMN(1)=0.0
        XMX(1)=DELR(NCOL)
        XLOC(1)=DELR(NCOL)/2.0
        DO 31 J=2,NCOL
        JJ=NCOL-J+1
        XMN(J)=XMX(J-1)
        XMX(J)=XMN(J)+DELR(JJ)
        XLOC(J)=(XMN(J)+XMX(J))/2.0
31      CONTINUE
      END IF
 
C  DELC, GRID SPACING ALONG A COLUMN (Y-DIRECTION)
C
      IF(IYDIR.EQ.0) THEN
        YMN(1)=0.0
        YMX(1)=DELC(NROW)
        YLOC(1)= YMX(1)/2.0
        DO 42 I=2,NROW
        II=NROW-I+1
        YMN(I)=YMX(I-1)
        YMX(I)=YMN(I)+DELC(II)
        YLOC(I)=(YMN(I)+YMX(I))/2.0
42      CONTINUE
      ELSE
        YMN(1)=0.0
        YMX(1)=DELC(1)
        YLOC(1)=DELC(1)/2.0
        DO 43 I=2,NROW
        YMN(I)=YMX(I-1)
        YMX(I)=YMN(I)+DELC(I)
        YLOC(I)=(YMN(I)+YMX(I))/2.0
43      CONTINUE
      END IF
C
C
C  IBOUND DATA
C
      ANAME='IBOUND'
      IF(IXREAD.EQ.0 .OR. NROW.GT.1) THEN
        DO 80 K=1,NLAY
        CALL U2DINT(IBOUND(1,1,K),ANAME,NROW,NCOL,K,IU,IUSUM)
80      CONTINUE
      ELSE
        CALL U2DINT(IBOUND,ANAME,NLAY,NCOL,-1,IU,IUSUM)
      END IF
 
      DO 81 K=1,NLAY
      DO 81 I=1,NROW
      DO 81 J=1,NCOL
      IBPZON(J,I,K)= IBOUND(J,I,K)
81    IF(IBPZON(J,I,K).LT.0) IBPZON(J,I,K)= -IBPZON(J,I,K)
 
C
C  POROSITY DATA
C
C  POROSITY DATA IS NOT USED BY MODPATH-PLOT, SO JUST READ THE ARRAYS INTO BUFF AND FORGET THEM
      DO 85 K=1,NLAY
      ANAME= 'POROSITY'
      CALL U2DREL(BUFF,ANAME,NROW,NCOL,K,IU,IUSUM)
      LCON=NCON(K)
      IF(LCON.GT.0) THEN
      ANAME= 'CONFINING BED POROSITY'
      CALL U2DREL(BUFF,ANAME,NROW,NCOL,K,IU,IUSUM)
      END IF
85    CONTINUE
C
C  STRESS PERIOD DATA FOR TRANSIENT SIMULATIONS
C
      TBEGIN=0.0
      IF(ISS.EQ.0) THEN
 
      READ(IU,'(A)') LINE
      ICOL=1
      CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,3,NDUMMY,TBEGIN,IUSUM,IU)
      WRITE(IUSUM,5320) TBEGIN
5320  FORMAT(1X/1X,'TIME AT BEGINNING OF SIMULATION = ',E14.6)
      DO 87 N=1,NPER
      WRITE(IUSUM,5340) N,PERLEN(N),NUMTS(N),TIMX(N)
5340  FORMAT(1X,'PERIOD',I4,':  LENGTH = ',E14.6,'  STEPS =',I4,
     1'  EXPANSION FACTOR =',F6.3)
87    CONTINUE
      WRITE(IUSUM,*) 'TIME STEP SUMMARY:'
      TSIM=TBEGIN
      DO 89 N=1,NPER
      KKK=NUMTS(N)
      DO 89 KK=1,KKK
      CALL STPSIZ(PERLEN(N),KK,KKK,TIMX(N),STPL)
      TSIM=TSIM+STPL
      WRITE(IUSUM,5345) N,KK,STPL,TSIM
5345  FORMAT(1X,'PERIOD',I4,' STEP',I4,': DELT =',E14.6,
     1' TIME AT END OF STEP =',E14.6)
89    CONTINUE
 
      IF(IPER.EQ.0 .AND. ISTP.EQ.0) THEN
        TIMREL=REFTIM
        CALL GETPS(PERLEN,NUMTS,TIMX,NPER,TIMREL,TBEGIN,IPER,ISTP,IERR)
        IF(IERR.NE.0) THEN
          WRITE(IUSUM,*) 'THE VALUE OF SIMULATION TIME SPECIFIED FOR COM
     1PUTING THE ACTIVE GRID AND CONTOURS IS INVALID.'
          WRITE(IUSUM,*) 'RUN STOPPED.'
          STOP
        END IF
        WRITE(IUSUM,*) ' '
        WRITE(IUSUM,5346) REFTIM
5346  FORMAT(1X,'SIMULATION TIME WILL BE USED TO COMPUTE PERIOD AND TIME
     1 STEP FOR ACTIVE GRID AND CONTOURS.'/1X,'SIMULATION TIME = ',
     2 1PE12.5)
        WRITE(IUSUM,5347) IPER,ISTP
5347  FORMAT(1X,'STRESS PERIOD = ',I4,' TIME STEP = ',I4)
      END IF
      END IF
C
C
C  READ HEADS
C
C-----INITIALIZE HEAD TO 0
      DO 90 K=1,NLAY
      DO 90 I=1,NROW
      DO 90 J=1,NCOL
90    HEAD(J,I,K)=0.
 
      II=0
      DO 92 K=1,NLAY
92    IF(LAYCON(K).GT.0) II=1
 
      IF(IUCBF.GT.0) THEN
        IHREAD=2
      ELSE IF(II.EQ.0) THEN
        IHREAD=0
      ELSE
        IHREAD=1
      END IF
 
C... TURN OFF THE HEAD READ FLAG FOR SOME CASES WHERE IT IS NOT
C    MANDITORY TO READ HEAD DATA
C
C  MAP VIEW, TYPES 6, 7, AND 8
      IF(IVIEW.EQ.1) THEN
        IF(ITYPE.EQ.6 .OR.
     1     ITYPE.EQ.7 .OR.
     2     ITYPE.EQ.8     ) THEN
          IHREAD=0
        END IF
      END IF
C  CROSS SECTION, TYPE 8 (GRID ONLY) WHEN TOP BOUNDARY IS NOT WATER TABLE
      IF(IVIEW.GT.1 .AND. ITYPE.EQ.8 .AND. LAYCON(1).NE.1) IHREAD=0
 
      IF(IHREAD.LT.2) THEN
        IF(IUNIT(8).NE.0 .AND. IUNIT(13).NE.0) THEN
        WRITE(*,*)
     1'CANNOT SPECIFIY BOTH FORMATTED AND UNFORMATTED HEAD FILES. STOP'
        WRITE(IUSUM,*)
     1'CANNOT SPECIFIY BOTH FORMATTED AND UNFORMATTED HEAD FILES. STOP'
        STOP
        END IF
 
        IUHED=0
        IF(IUNIT(8).NE.0) THEN
          IUHED= -IUNIT(8)
        ELSE IF(IUNIT(13).NE.0) THEN
          IUHED=IUNIT(13)
        END IF
 
        IF(IUHED.NE.0 .AND. IHREAD.EQ.0) IHREAD=1
      END IF
 
      IF(IHREAD.EQ.1 .AND. IUHED.EQ.0) THEN
        WRITE(*,*)
     1    ' A MODFLOW-GENERATED HEAD OUTPUT FILE IS REQUIRED. STOP.'
        WRITE(IUSUM,*)
     1    ' A MODFLOW-GENERATED HEAD OUTPUT FILE IS REQUIRED. STOP.'
        STOP
      ELSE IF(IHREAD.EQ.1 .AND. IUHED.NE.0) THEN
        CALL HEDINP(HEAD,BUFF,NCOL,NROW,NLAY,IUHED,ISTP,IPER,IUSUM)
        WRITE(IUSUM,*) 'HEADS HAVE BEEN READ'
      ELSE IF(IHREAD.EQ.2) THEN
        IF(IUCBF.EQ.0) THEN
          WRITE(*,*)
     1    ' A COMPOSITE BUDGET FILE IS REQUIRED. STOP'
          WRITE(IUSUM,*)
     1    ' A COMPOSITE BUDGET FILE IS REQUIRED. STOP'
          STOP
        END IF
        IPERCP=IPER
        ISTPCP=ISTP
        CALL CBFHED(HEAD,NCOL,NROW,NLAY,IUCBF,NSTEP,IERR,NUMTS,NPER,
     1            NSTEPF,NSTEPL,IPERCP,ISTPCP,2,IUSUM)
        WRITE(IUSUM,*) 'HEADS HAVE BEEN READ'
      END IF
 
      IF(IUHED.LT.0) IUHED= -IUHED
      IF(IUHED.NE.0) CLOSE(IUHED)
 
 
 
 
C   IF GRID IS STRATIGRAPHIC 3-D, THEN...
      IF(IGRID.EQ.0) THEN
      DO 140 K=1,NLAY
      DELZ(K)=0.0
      COWNT=0.0
      DO 120 I=1,NROW
      DO 120 J=1,NCOL
      IF(IBOUND(J,I,K).EQ.0 .OR. HEAD(J,I,K).EQ.HDRY) GO TO 120
      COWNT=COWNT+1.0E+0
      JIK= (K-1)*NCOL*NROW + (I-1)*NCOL + J
      IF(LAYCON(K).LE.0) THEN
      DELZ(K)=DELZ(K) + (ZTOP(JIK)-ZBOT(JIK))
      ELSE IF(LAYCON(K).GT.1) THEN
        IF(HEAD(J,I,K).GT.ZTOP(JIK)) THEN
          DELZ(K)=DELZ(K)+(ZTOP(JIK)-ZBOT(JIK))
        ELSE
          DELZ(K)=DELZ(K)+(HEAD(J,I,K)-ZBOT(JIK))
        END IF
      ELSE
      DELZ(K)=DELZ(K) + (HEAD(J,I,K)-ZBOT(JIK))
      END IF
120    CONTINUE
      IF(COWNT.GT.0.0) THEN
        DELZ(K)=DELZ(K)/COWNT
      ELSE
        DELZ(K)=0.0
      END IF
      DELZCB(K)=0.0
      COWNT=0.0
      IF(NCON(K).EQ.0) GO TO 140
      DO 130 I=1,NROW
      DO 130 J=1,NCOL
      IF(IBOUND(J,I,K).EQ.0 .OR. HEAD(J,I,K).EQ.HDRY) GO TO 130
      COWNT=COWNT+1.0E+0
      JIK= (K-1)*NCOL*NROW + (I-1)*NCOL + J
      JIK1=JIK+(NCOL*NROW)
      DELZCB(K)= DELZCB(K) + (ZBOT(JIK)-ZTOP(JIK1))
130    CONTINUE
      IF(COWNT.GT.0.0) THEN
        DELZCB(K)=DELZCB(K)/COWNT
      ELSE
        DELZCB(K)=0.0
      END IF
140    CONTINUE
      ZMX(NLAY)=DELZ(NLAY)
      ZMN(NLAY)=0.0
      DO 150 K=2,NLAY
      KK=NLAY+1-K
      ZMN(KK)=ZMX(KK+1)+DELZCB(KK)
      ZMX(KK)=ZMN(KK)+DELZ(KK)
150    CONTINUE
 
C  ELSE IF GRID IS TRUE-RECTANGULAR 3-D, THEN...
      ELSE IF (IGRID.EQ.1) THEN
      IF(LAYCON(1).EQ.1) THEN
      DELZ(1)=0.0
      COWNT=0.0
      DO 160 I=1,NROW
      DO 160 J=1,NCOL
      IF(IBOUND(J,I,1).EQ.0 .OR. HEAD(J,I,1).EQ.HDRY) GO TO 160
      COWNT=COWNT+1.0E+0
      DELZ(1)=DELZ(1) + (HEAD(J,I,1)-ZBOT(1))
160   CONTINUE
      IF(COWNT.GT.0.0) THEN
        DELZ(1)=DELZ(1)/COWNT
      ELSE
        DELZ(1)=0.0
      END IF
      END IF
      ZMX(1)=ZBOT(1) + DELZ(1)
      ZMN(1)=ZBOT(1)
      DO 170 K=2,NLAY
      ZMX(K)=ZTOP(K)
      ZMN(K)=ZBOT(K)
170   CONTINUE
      END IF
 
 
 
C
C---READ IN GRID UNIT DATA
C
      IF(IUIGZ.GT.0) THEN
        CALL GUADAT(IBUFF,BUFF,NCOL,NROW,NLAY,IXREAD,IUIGZ,IUSUM,
     1             LMESS,NLMESS,NGUA,TLEGND)
      END IF
C
 
C---CONSTRUCT 2D GEOLOGIC ZONE ARRAY AND 2D CROSS SECTION ARRAYS
C
C-----INITIALIZE GRID UNIT ARRAY TO 0
        DO 190 N=1,NIGZ
190     IGZ(N)=0
C
      IF(IVIEW.EQ.1) THEN
        DO 210 I=1,NROW
        DO 210 J=1,NCOL
        NN= (I-1)*NCOL + J
        ZXT(NN)=YMX(NROW-I+1)
        ZXB(NN)=YMN(NROW-I+1)
        IF(IUIGZ.GT.0) IGZ(NN)=IBUFF(J,I,ISLICE)
210     CONTINUE
      ELSE IF(IVIEW.EQ.2) THEN
        NHOR=NROW
        IREV=1-IYDIR
        CALL NEWIXA(IVIEW,IBOUND,IBX,NCOL,NROW,NLAY,NHOR,ISLICE,IREV,0)
        IF(IUIGZ.GT.0) THEN
          CALL NEWIXA(IVIEW,IBUFF,IGZ,NCOL,NROW,NLAY,NHOR,ISLICE,IREV,0)
        END IF
        IF(IGRID.EQ.0 .AND. IXTYPE.GT.0) THEN
          CALL NEWRXA(IVIEW,ZBOT,ZXB,NCOL,NROW,NLAY,NHOR,ISLICE,IREV)
          CALL NEWRXA(IVIEW,ZTOP,ZXT,NCOL,NROW,NLAY,NHOR,ISLICE,IREV)
        ELSE
          DO 215 K=1,NLAY
          DO 215 J=1,NHOR
          NN= (K-1)*NHOR + J
          ZXT(NN)=ZMX(K)
215       ZXB(NN)=ZMN(K)
        END IF
      ELSE IF(IVIEW.EQ.3) THEN
        NHOR=NCOL
        CALL NEWIXA(IVIEW,IBOUND,IBX,NCOL,NROW,NLAY,NHOR,ISLICE,IXDIR,0)
        IF(IUIGZ.GT.0) THEN
         CALL NEWIXA(IVIEW,IBUFF,IGZ,NCOL,NROW,NLAY,NHOR,ISLICE,IXDIR,0)
        END IF
        IF(IGRID.EQ.0 .AND. IXTYPE.GT.0) THEN
          CALL NEWRXA(IVIEW,ZBOT,ZXB,NCOL,NROW,NLAY,NHOR,ISLICE,IXDIR)
          CALL NEWRXA(IVIEW,ZTOP,ZXT,NCOL,NROW,NLAY,NHOR,ISLICE,IXDIR)
        ELSE
          DO 220 K=1,NLAY
          DO 220 J=1,NHOR
          NN= (K-1)*NHOR + J
          ZXT(NN)=ZMX(K)
220       ZXB(NN)=ZMN(K)
        END IF
      END IF
 
 
C---ADJUST TOP EVEVATION OF ZXT ARRAY IF LAYER 1 IS UNCONFINED AND THE PLOT
C   IS A TRUE CROSS SECTION
C
      IF(IVIEW.GT.1 .AND. IXTYPE.GT.0 .AND. LAYCON(1).EQ.1) THEN
        IF(IVIEW.EQ.2) THEN
          NHOR=NROW
          CALL TOPWT(ZXT,ZXB,NHOR,IREV,HEAD,HNOFLO,HDRY,NCOL,NROW,NLAY,
     1                 ISLICE,IVIEW,BUFF)
        ELSE IF(IVIEW.EQ.3) THEN
          NHOR=NCOL
          CALL TOPWT(ZXT,ZXB,NHOR,IXDIR,HEAD,HNOFLO,HDRY,NCOL,NROW,NLAY,
     1                 ISLICE,IVIEW,BUFF)
        END IF
      END IF
 
      CLOSE(IU)
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE GETGZ(IBUFF,BUFF,NCOL,NROW,NLAY,IXREAD,IU,IO,LMESS,
     1                 NLMESS,NGUA)
      DIMENSION IBUFF(NCOL,NROW,NLAY),BUFF(NCOL,NROW,NLAY)
      CHARACTER*30 LMESS(2*NLMESS)
      CHARACTER*24 ANAME
      CHARACTER*81 LINE
C
      ANAME='GRID UNITS'
 
      DO 10 K=1,NLAY
      DO 10 I=1,NROW
      DO 10 J=1,NCOL
      IBUFF(J,I,K)=0
10    BUFF(J,I,K)=0.0
 
      READ(IU,'(A)',END=100) LINE
      ICOL=1
      CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,1,IDUMMY,RDUMMY,IO,IU)
 
      IOP=1
      IF(LINE(IWSTRT:IWLAST).EQ.'ZONES') THEN
        IOP=1
      ELSE IF(LINE(IWSTRT:IWLAST).EQ.'RANGES') THEN
        IOP=2
      END IF
 
      IF(IOP.EQ.1) THEN
        IF(IXREAD.EQ.0 .OR. NROW.GT.1) THEN
          DO 200 K=1,NLAY
          CALL U2DINT(IBUFF(1,1,K),ANAME,NROW,NCOL,K,IU,IO)
200       CONTINUE
        ELSE
          CALL U2DINT(IBUFF,ANAME,NLAY,NCOL,-1,IU,IO)
        END IF
 
      ELSE IF(IOP.EQ.2) THEN
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,2,IZNS,RDUMMY,IO,IU)
        IF(IZNS.EQ.0) GO TO 100
        IF(IXREAD.EQ.0 .OR. NROW.GT.1) THEN
          DO 210 K=1,NLAY
          CALL U2DREL(BUFF(1,1,K),ANAME,NROW,NCOL,K,IU,IO)
210       CONTINUE
        ELSE
          CALL U2DREL(BUFF,ANAME,NLAY,NCOL,-1,IU,IO)
        END IF
        DO 20 N=1,IZNS
        READ(IU,'(A)') LINE
        ICOL=1
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,2,IGNUM,RDUMMY,IO,IU)
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,3,NDUMMY,CMIN,IO,IU)
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,3,NDUMMY,CMAX,IO,IU)
        DO 30 K=1,NLAY
        DO 30 I=1,NROW
        DO 30 J=1,NCOL
        IF(BUFF(J,I,K).GE.CMIN .AND. BUFF(J,I,K).LE.CMAX) THEN
          IBUFF(J,I,K)=IGNUM
        END IF
30      CONTINUE
20      CONTINUE
      END IF
100   CONTINUE
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE HEDINP(HEAD,BUFF,NCOL,NROW,NLAY,IUHED,ISTP,IPER,IO)
      CHARACTER*16 TEXT
      CHARACTER*132 LINE
      DIMENSION HEAD(NCOL,NROW,NLAY),BUFF(NCOL*NROW*NLAY)
 
 
C---FIND OUT IF THE HEADS ARE SAVED AS A SINGLE VERTICAL SLICE IF NROW=1
      IHTYPE=0
      IF(NROW.EQ.1) THEN
        IF(IUHED.LT.0) THEN
          READ(-IUHED) KSTP,KPER,PERTIM,TOTIM,TEXT,NC,NR,K
          IF(K.LT.0) IHTYPE=1
          REWIND(-IUHED)
        ELSE
          READ(IUHED,'(A)') LINE
          ICOL=1
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,2,KSTP,RDUMMY,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,2,KPER,RDUMMY,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,3,IDUMMY,PERTIM,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,3,IDUMMY,TOTIM,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,1,IDUMMY,RDUMMY,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,2,NC,RDUMMY,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,2,NR,RDUMMY,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,2,K,RDUMMY,IO,IU)
          CALL URWORD(LINE,ICOL,IWFRST,IWLAST,1,IDUMMY,RDUMMY,IO,IU)
          IF(K.LT.0) IHTYPE=1
          REWIND(IUHED)
        END IF
      END IF
 
      TEXT= 'HEAD'
      IF(IHTYPE.EQ.0) THEN
10    CONTINUE
      CALL GETLAY(BUFF,KSTP,KPER,PERTIM,TOTIM,TEXT,NC,NR,K,NCOL,
     1            NROW,IUHED,IO,IEND,0)
      IF(IEND.EQ.1) GO TO 25
      IF(ISTP.EQ.KSTP .AND. IPER.EQ.KPER) THEN
      DO 20 I=1,NROW
      DO 20 J=1,NCOL
      NN=(I-1)*NCOL + J
20    HEAD(J,I,K)=BUFF(NN)
      END IF
      GO TO 10
25    CONTINUE
 
      ELSE
30    CONTINUE
      CALL GETLAY(BUFF,KSTP,KPER,PERTIM,TOTIM,TEXT,NC,NL,K,NCOL,
     1            NLAY,IUHED,IO,IEND,0)
      IF(IEND.EQ.1) GO TO 45
      IF(ISTP.EQ.KSTP .AND. IPER.EQ.KPER) THEN
      DO 40 K=1,NLAY
      DO 40 J=1,NCOL
      NN= (K-1)*NCOL + J
40    HEAD(J,1,K)=BUFF(NN)
      END IF
      GO TO 30
45    CONTINUE
      END IF
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE BRECT(NX,NZ,JMIN,JMAX,KMIN,KMAX,XMIN,XMAX,ZXT,ZXB,
     1  XGMIN,XGMAX,ZGMIN,ZGMAX,ZBOT,ZTOP,NZDIM,VEX)
      DIMENSION ZXT(NX,NZ),ZXB(NX,NZ),XMIN(NX),XMAX(NX),ZBOT(NZDIM),
     1 ZTOP(NZDIM)
C
      XGMIN= XMIN(JMIN)
      XGMAX= XMAX(JMAX)
 
      DO 1 N=1,NZDIM
      ZBOT(N)= VEX*ZBOT(N)
1     ZTOP(N)= VEX*ZTOP(N)
 
      DO 5 K=1,NZ
      DO 5 J=1,NX
      ZXT(J,K)= VEX*ZXT(J,K)
5     ZXB(J,K)= VEX*ZXB(J,K)
 
      JMN=JMIN
      JMX=JMAX
      IF (JMIN.GT.1) JMN=JMIN-1
      IF (JMAX.LT.NX) JMX=JMAX+1
      DO 10 J=JMN,JMX
 
      IF(J.EQ.JMN) THEN
        ZGMIN=ZXB(JMN,KMAX)
      ELSE
        IF(ZXB(J,KMAX).LT.ZGMIN) ZGMIN=ZXB(J,KMAX)
      END IF
 
      IF(J.EQ.JMN) THEN
        ZGMAX=ZXT(J,KMIN)
      ELSE
        IF(ZXT(J,KMIN).GT.ZGMAX) ZGMAX=ZXT(J,KMIN)
      END IF
 
10    CONTINUE
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE CBFHED(HEAD,NCOL,NROW,NLAY,IU,NSTEP,IERR,NUMTS,
     2 NPER,NSTEPF,NSTEPL,KPER,KSTP,IOPT,IUSUM)
      INTEGER*4 NHLAY4,NSTP4,IPER4,ISTP4,NNSTP4,K4
C
      DIMENSION HEAD(NCOL,NROW,NLAY),NUMTS(NPER)
C
      IERR=0
C
      READ(IU,REC=1,ERR=9000) NHLAY4,NSTP4
      NHLAY= NHLAY4
      NSTPSV=NSTP4
C
      NRPTS= (6*NROW*NLAY) + (NROW*NHLAY) + NROW + NLAY
C
C... READ TIME STEP HEADERS FOR FIRST AND LAST STEPS & COMPUTE STEP NUMB
C    RETURN WITH ERROR CODE = 1 IF REQUESTED STEP IS OUT OF RANGE
      READ(IU,REC=2) IPER4,ISTP4,DELT,TOTSIM,NNSTP4
      IPER=IPER4
      ISTP=ISTP4
      CALL GETSTP(IPER,ISTP,NUMTS,NPER,IUSUM,NSTEPF)
      NREC= 2 + (NSTPSV-1)*(NRPTS+1)
      READ(IU,REC=NREC) IPER4,ISTP4,DELT,TOTSIM,NNSTP4
      IPER=IPER4
      ISTP=ISTP4
      CALL GETSTP(IPER,ISTP,NUMTS,NPER,IUSUM,NSTEPL)
      IF(IOPT.EQ.0) RETURN
      IF(IOPT.EQ.2) CALL GETSTP(KPER,KSTP,NUMTS,NPER,IUSUM,NSTEP)
      IF(NSTEP.LT.NSTEPF .OR. NSTEP.GT.NSTEPL) THEN
      IERR=1
      RETURN
      END IF
 
      N=NSTEP - NSTEPF + 1
C... READ TIME STEP HEADER
      NREC= 2 + (N-1)*(NRPTS+1)
      READ(IU,REC=NREC) IPER4,ISTP4,DELT,TOTSIM,NNSTP4
      IPER=IPER4
      ISTP=ISTP4
      IF(IOPT.EQ.2) THEN
        IF(KPER.NE.IPER .OR. KSTP.NE.ISTP) THEN
          IERR=2
          RETURN
        END IF
      END IF
      KPER=IPER
      KSTP=ISTP
 
C... SKIP OVER EVERTHING ELSE TO GET TO HEAD DATA
      NREC=NREC + (6*NROW*NLAY) + NROW + NLAY
 
C... READ HEAD
      DO 10 K=1,NLAY
      DO 10 I=1,NROW
      DO 10 J=1,NCOL
10    HEAD(J,I,K)=0.0
c
      DO 20 N=1,NHLAY
      DO 30 I=1,NROW
      NREC=NREC+1
      READ(IU,REC=NREC) (HEAD(J,I,NLAY),J=1,NCOL),K4
      K=K4
      DO 40 J=1,NCOL
40    HEAD(J,I,K)=HEAD(J,I,NLAY)
      IF(N.EQ.NHLAY .AND. K.NE.NLAY) THEN
        DO 45 II=1,NROW
        DO 45 JJ=1,NCOL
45      HEAD(JJ,II,NLAY)=0.0
      END IF
30    CONTINUE
20    CONTINUE
C
      RETURN
9000  WRITE(IUSUM,*) 'ERROR READING COMPOSITE BUDGET FILE. STOP.'
      STOP
      END
 
C***** SUBROUTINE *****
      SUBROUTINE NEWIXA (IVIEW,IA3D,IA2D,NCOL,NROW,NLAY,NH,L,IRH,IRV)
      DIMENSION IA3D(NCOL,NROW,NLAY),IA2D(NH,NLAY)
C
C  IF VIEW IS ALONG A COLUMN, THEN...
      IF(IVIEW.EQ.2) THEN
        DO 10 K=1,NLAY
        DO 10 I=1,NROW
        KK=K
        II=I
        IF(IRH.EQ.1) II=NROW-I+1
        IF(IRV.EQ.1) KK=NLAY-K+1
        IA2D(I,K)= IA3D(L,II,KK)
10      CONTINUE
 
C  IF VIEW IS ALONG A ROW, THEN...
      ELSE IF(IVIEW.EQ.3) THEN
        DO 20 K=1,NLAY
        DO 20 J=1,NCOL
        KK=K
        JJ=J
        IF(IRH.EQ.1) JJ=NCOL-J+1
        IF(IRV.EQ.1) KK=NLAY-K+1
        IA2D(J,K)=IA3D(JJ,L,KK)
20      CONTINUE
      END IF
 
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE NEWRXA (IVIEW,RA3D,RA2D,NCOL,NROW,NLAY,NH,L,IREV)
      DIMENSION RA3D(NCOL,NROW,NLAY),RA2D(NH,NLAY)
C
C  IF VIEW IS ALONG A COLUMN, THEN...
      IF(IVIEW.EQ.2) THEN
        DO 10 K=1,NLAY
        DO 10 I=1,NROW
        RA2D(I,K)= RA3D(L,I,K)
10      CONTINUE
C  REVERSE ROWS IF NECESSARY...
        IF(IREV.EQ.1) THEN
          NRHALF=NROW/2
          DO 15 K=1,NLAY
          DO 15 I=1,NRHALF
          II=NROW-I+1
          TEMP=RA2D(I,K)
          RA2D(I,K)=RA2D(II,K)
          RA2D(II,K)=TEMP
15        CONTINUE
        END IF
 
C  IF VIEW IS ALONG A ROW, THEN...
      ELSE IF(IVIEW.EQ.3) THEN
        DO 20 K=1,NLAY
        DO 20 J=1,NCOL
        RA2D(J,K)=RA3D(J,L,K)
20      CONTINUE
C  REVERSE COLUMNS IF NECESSARY...
        IF(IREV.EQ.1) THEN
          NCHALF=NCOL/2
          DO 25 K=1,NLAY
          DO 25 J=1,NCHALF
          JJ=NCOL-J+1
          TEMP=RA2D(J,K)
          RA2D(J,K)=RA2D(JJ,K)
          RA2D(JJ,K)=TEMP
25        CONTINUE
        END IF
      END IF
      RETURN
      END
 
C***** SUBROUTINE *****
      SUBROUTINE GUADAT(IBUFF,BUFF,NCOL,NROW,NLAY,IXREAD,IU,IO,LMESS,
     1                 NLMESS,NGUA,TLEGND)
      DIMENSION IBUFF(NCOL,NROW,NLAY),BUFF(NCOL,NROW,NLAY),NGUA(NLMESS)
      CHARACTER*30 LMESS(NLMESS),STR1,STR2
      CHARACTER*50 TLEGND
      CHARACTER*24 ANAME
      CHARACTER*81 LINE
C
      ANAME='GRID UNITS'
 
      DO 1 N=1,NLMESS
      NGUA(N)=0
      LMESS(N)= ' '
1     CONTINUE
 
      DO 10 K=1,NLAY
      DO 10 I=1,NROW
      DO 10 J=1,NCOL
      IBUFF(J,I,K)=0
10    BUFF(J,I,K)=0.0
 
      READ(IU,'(A)',END=100) LINE
      ICOL=1
      CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,1,IDUMMY,RDUMMY,IO,IU)
 
      IOP=1
      IF(LINE(IWSTRT:IWLAST).EQ.'ZONES') THEN
        IOP=1
      ELSE IF(LINE(IWSTRT:IWLAST).EQ.'RANGES') THEN
        IOP=2
      END IF
 
      READ(IU,'(A)') TLEGND
 
C--- IF OPTION IS "ZONES", THEN
      IF(IOP.EQ.1) THEN
        IF(IXREAD.EQ.0 .OR. NROW.GT.1) THEN
          DO 200 K=1,NLAY
          CALL U2DINT(IBUFF(1,1,K),ANAME,NROW,NCOL,K,IU,IO)
200       CONTINUE
        ELSE
          CALL U2DINT(IBUFF,ANAME,NLAY,NCOL,-1,IU,IO)
        END IF
 
        KOUNT=0
50      CONTINUE
        READ(IU,'(A)',END=60) LINE
        IF(KOUNT.EQ.NLMESS) GO TO 60
        ICOL=1
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,2,IGNUM,RDUMMY,-1,IU)
        IF(LINE(81:81).EQ.'E') GO TO 50
        KOUNT=KOUNT+1
        NGUA(KOUNT)=IGNUM
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,0,IDUMMY,RDUMMY,IO,IU)
        IF(IWSTRT.LT.81) THEN
          LMESS(KOUNT)= LINE(IWSTRT:81)
        ELSE
          LMESS(KOUNT)= ' '
        END IF
        GO TO 50
60      CONTINUE
 
C--- ELSE, IF OPTION IS "RANGES", THEN
      ELSE IF(IOP.EQ.2) THEN
        IF(IXREAD.EQ.0 .OR. NROW.GT.1) THEN
          DO 210 K=1,NLAY
          CALL U2DREL(BUFF(1,1,K),ANAME,NROW,NCOL,K,IU,IO)
210       CONTINUE
        ELSE
          CALL U2DREL(BUFF,ANAME,NLAY,NCOL,-1,IU,IO)
        END IF
 
        KOUNT=0
20      CONTINUE
        STR1= ' '
        STR2= ' '
        READ(IU,'(A)',END=40) LINE
        KOUNT=KOUNT+1
        ICOL=1
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,2,IGNUM,RDUMMY,IO,IU)
          IF(KOUNT.LE.NLMESS) NGUA(KOUNT)=IGNUM
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,3,NDUMMY,CMIN,-1,IU)
          IF(LINE(IWSTRT:IWLAST) .EQ. '<') CMIN= -1.0E+30
          IF(KOUNT.LE.NLMESS) STR1= LINE(IWSTRT:IWLAST)
        CALL URWORD(LINE,ICOL,IWSTRT,IWLAST,3,NDUMMY,CMAX,-1,IU)
          IF(LINE(IWSTRT:IWLAST) .EQ. '>') CMAX= 1.0E+30
          IF(KOUNT.LE.NLMESS) STR2= LINE(IWSTRT:IWLAST)
        DO 30 K=1,NLAY
        DO 30 I=1,NROW
        DO 30 J=1,NCOL
        IF(BUFF(J,I,K).GE.CMIN .AND. BUFF(J,I,K).LE.CMAX) THEN
          IBUFF(J,I,K)=IGNUM
        END IF
30      CONTINUE
        IF(KOUNT.LE.NLMESS) THEN
          CALL CHOP(STR1,LSTR1)
          CALL CHOP(STR2,LSTR2)
          IF(LSTR1.LE.0) LSTR1=1
          IF(LSTR2.LE.0) LSTR2=1
          IF(STR1 .EQ. '<' .AND. STR2 .NE. '>') THEN
            LMESS(KOUNT)= '< '//STR2(1:LSTR2)
          ELSE IF(STR1 .NE. '<' .AND. STR2 .EQ. '>') THEN
            LMESS(KOUNT)= '> '//STR1(1:LSTR1)
          ELSE IF(STR1 .NE. '<' .AND. STR2 .NE. '>') THEN
            LMESS(KOUNT)= STR1(1:LSTR1)//' TO '//STR2(1:LSTR2)
          ELSE
            LMESS(KOUNT)= ' '
          END IF
        END IF
        GO TO 20
40      CONTINUE
      END IF
100   CONTINUE
      RETURN
      END
